{"version":3,"file":"index.js","sources":["../src/utils/query-param/decorator.ts","../src/utils/query-param/helpers.ts","../src/utils/query-param/index.ts"],"sourcesContent":["function isClassDescriptor(possibleDesc: [any]) {\n  let [target] = possibleDesc;\n\n  return (\n    possibleDesc.length === 1 &&\n    typeof target === 'function' &&\n    'prototype' in target &&\n    !target.__isComputedDecorator\n  );\n}\n\nexport function isFieldDescriptor(possibleDesc: [any, any, any]) {\n  let [target, key, desc] = possibleDesc;\n\n  return (\n    possibleDesc.length === 3 &&\n    typeof target === 'object' &&\n    target !== null &&\n    typeof key === 'string' &&\n    ((typeof desc === 'object' &&\n      desc !== null &&\n      'enumerable' in desc &&\n      'configurable' in desc) ||\n      desc === undefined) // TS compatibility\n  );\n}\n\nexport function isDescriptor(possibleDesc: any) {\n  return isFieldDescriptor(possibleDesc) || isClassDescriptor(possibleDesc);\n}\n\n/**\n * A macro that takes a decorator function and allows it to optionally\n * receive parameters\n *\n * ```js\n * let foo = decoratorWithParams((target, desc, key, params) => {\n *   console.log(params);\n * });\n *\n * class {\n *   @foo bar; // undefined\n *   @foo('bar') baz; // ['bar']\n * }\n * ```\n *\n * @param {Function} fn - decorator function\n */\nexport function decoratorWithParams(fn: (...args: any[]) => void) {\n  return function (...params: unknown[]) {\n    // determine if user called as @computed('blah', 'blah') or @computed\n    if (isDescriptor(params)) {\n      return fn(...params);\n    } else {\n      return (...desc: unknown[]) => fn(...desc, params);\n    }\n  };\n}\n","import { getOwner } from '@ember/application';\nimport { assert } from '@ember/debug';\n\nimport type { default as QueryParamsService } from '../../services/query-params';\n\nexport interface ITransformOptions<T> {\n  defaultValue?: string;\n  deserialize?: (queryParam: string) => T;\n  serialize?: (queryParam: T) => string;\n}\n\nexport type Args<T> = [] | [string, ITransformOptions<T>] | [ITransformOptions<T>] | [string];\n\nexport function extractArgs<T>(args: Args<T>, propertyKey: string): [string, ITransformOptions<T>] {\n  const [maybePathMaybeOptions, maybeOptions] = args;\n\n  let propertyPath: string;\n  let options: ITransformOptions<T>;\n\n  if (typeof maybePathMaybeOptions === 'string') {\n    propertyPath = `current.${maybePathMaybeOptions}`;\n    options = maybeOptions || {};\n  } else {\n    propertyPath = `current.${propertyKey}`;\n    options = maybePathMaybeOptions || {};\n  }\n\n  return [propertyPath, options];\n}\n\nexport function tryDeserialize<T>(value: any, options: ITransformOptions<T>) {\n  value = value ?? options.defaultValue;\n\n  if (!options.deserialize) return value;\n\n  return options.deserialize(value);\n}\n\nexport function trySerialize<T>(value: any, options: ITransformOptions<T>) {\n  if (value === options.defaultValue) {\n    value = undefined;\n  }\n\n  if (!options.serialize) return value;\n\n  return options.serialize(value);\n}\n\n// can't cache the service in module space because we run in to race  conditions\n// where a service on an old app instance may still exist, but be tied to the\n// old application instead of the current one (such as in tests)\nconst serviceCache = new WeakMap();\n\nexport function ensureService(context: any): QueryParamsService {\n  let service = serviceCache.get(context);\n\n  if (!service) {\n    service = getQPService(context);\n\n    serviceCache.set(context, service);\n  }\n\n  return service;\n}\n\nexport function getQPService(context: any): QueryParamsService {\n  let owner = getOwner(context);\n\n  assert(`context does not have an owner, and an owner is required for accessing services`, owner);\n\n  return owner.lookup('service:query-params') as unknown as QueryParamsService;\n}\n","import { get, set } from '@ember/object';\n\nimport { decoratorWithParams } from './decorator';\nimport { ensureService, extractArgs, tryDeserialize, trySerialize } from './helpers';\n\nimport type { Args } from './helpers';\n\n// type DecoratorCreator = (...args: Args<string>) => PropertyDecorator;\n// type DecoratorWithParams = PropertyDecorator | DecoratorCreator;\n\nexport const queryParam = decoratorWithParams(\n  queryParamWithOptionalParams as any\n) as unknown as any; /* ugh */\n\nfunction queryParamWithOptionalParams<T = boolean>(\n  _target: any,\n  propertyKey: string,\n  sourceDescriptor?: any,\n  ...args: Args<T>\n): void {\n  const { get: oldGet, initializer } = sourceDescriptor;\n  // TODO: why is args sometimes an array of arrays?\n  const [propertyPath, options] = extractArgs<T>(args.flat() as Args<T>, propertyKey);\n\n  // There is no initializer, so stage 1 decorators actually\n  // don't have the capability to do what I want :(\n  // setupController(target);\n  //\n  // this means that in order to use any query param willy-nilly\n  // we'll need to prevent the router from looking up the controller\n  // to remove un-specified query params\n\n  const result = {\n    configurable: true,\n    enumerable: true,\n    get: function (): T | undefined {\n      // setupController(this, 'application');\n      const service = ensureService(this);\n      const value = get(service, propertyPath);\n      const deserialized = tryDeserialize(value, options);\n\n      return deserialized ?? oldGet?.() ?? initializer?.();\n    },\n    set: function (value?: T) {\n      // setupController(this, 'application');\n      const service = ensureService(this);\n      const serialized = trySerialize(value, options);\n\n      set<any>(service, propertyPath, serialized);\n    },\n  };\n\n  return result as any;\n}\n"],"names":["isClassDescriptor","possibleDesc","target","length","__isComputedDecorator","isFieldDescriptor","key","desc","undefined","isDescriptor","decoratorWithParams","fn","params","extractArgs","args","propertyKey","maybePathMaybeOptions","maybeOptions","propertyPath","options","tryDeserialize","value","defaultValue","deserialize","trySerialize","serialize","serviceCache","WeakMap","ensureService","context","service","get","getQPService","set","owner","getOwner","assert","lookup","queryParam","queryParamWithOptionalParams","_target","sourceDescriptor","oldGet","initializer","flat","result","configurable","enumerable","deserialized","serialized"],"mappings":"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"}